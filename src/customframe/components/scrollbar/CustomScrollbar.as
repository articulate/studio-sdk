package customframe.components.scrollbar{	import flash.display.Sprite;	import flash.events.*;	import flash.geom.Point;	import flash.text.TextField;	import flash.utils.Timer;	/**	 * This is the logic for the CustomScrollbar symbol in the library (/components/scrollbar/CustomScrollbar.)	 *	 * The CustomScrollbar draws a vertical scrollbar along the right side of a text field or list.	 * It dispatches ScrollbarEvents that tell the rext field or list how to set its scrollRect.	 *	 */	public class CustomScrollbar extends Sprite	{		private const SCROLL_INTERVAL = 100;		private const BUTTON_SIZE:int = 16;		private const WIDTH:int = BUTTON_SIZE;		private const UP:String = "up";		private const DOWN:String = "down";		public var track:Sprite;		private var m_nScrollPos:Number = 0;		private var m_nLastScrollPos:Number = 0;		private var m_nLastYPos:Number = 0;		private var m_nContentHeight:int = 0;		private var m_nYDragOffset:int = 0;		private var m_nLineHeight:int = 21;		private var m_strScrollDirection:String = "";		private var m_oScrollTimer:Timer = new Timer(SCROLL_INTERVAL);		private var m_spUpButton:ScrollUpButton = new ScrollUpButton();		private var m_spDownButton:ScrollDownButton = new ScrollDownButton();		private var m_spThumb:ScrollThumb = new ScrollThumb();		private var m_spThumbGrippers:ScrollThumbGrippers = new ScrollThumbGrippers();		public function CustomScrollbar()		{			super();			m_spUpButton.buttonMode = true;			m_spUpButton.useHandCursor = true;			m_spUpButton.addEventListener(MouseEvent.MOUSE_DOWN, UpButton_onMouseDown);			addChild(m_spUpButton);			m_spDownButton.buttonMode = true;			m_spDownButton.useHandCursor = true;			m_spDownButton.addEventListener(MouseEvent.MOUSE_DOWN, DownButton_onMouseDown);			addChild(m_spDownButton);			m_spThumb.addEventListener(MouseEvent.MOUSE_DOWN, Thumb_onMouseDown);			addChild(m_spThumb);			m_spThumbGrippers.mouseEnabled = false;			m_spThumbGrippers.mouseChildren = false;			addChild(m_spThumbGrippers);			addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);			addEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel);		}		public function get ContentHeight():int		{			return m_nContentHeight;		}		public function set ContentHeight(value:int):void		{			if (m_nContentHeight != value)			{				m_nContentHeight = value;			}			Update();		}		public override function get width():Number		{			return WIDTH;		}		public override function set width(value:Number):void		{			// Do Nothing		}		public override function get height():Number		{			return this.track.height;		}		public override function set height(value:Number):void		{			if (this.track.height != value)			{				this.track.height = value;				Update();			}		}		public function get Position():Number		{			return m_nScrollPos;		}		public function AutoScroll(nPosition:Number, nHeight:int):void		{			if (nPosition + nHeight > m_nScrollPos + this.height)			{				ScrollTo(nPosition - this.height + nHeight);			}			else if (nPosition < m_nScrollPos)			{				ScrollTo(nPosition);			}		}		public function ScrollTo(nPosition:Number, bNotify:Boolean = true):void		{			nPosition = Math.max(nPosition, 0);			nPosition = Math.min(nPosition, this.OffscreenHeight);			if (nPosition != m_nScrollPos)			{				m_nScrollPos = nPosition;				UpdateThumb();				if (bNotify)				{					DispatchScrollingEvent();				}			}		}		public function ScrollByLines(nLines:int):void		{			ScrollTo(m_nScrollPos + m_nLineHeight * nLines);		}		public function SyncToText(tfText:TextField):void		{			var nPosition:Number = ((tfText.scrollV - 1) / (tfText.maxScrollV - 1)) * (tfText.textHeight - tfText.height);			ScrollTo(nPosition, false);		}		private function UpdateThumb():void		{			m_spThumb.height = Math.max(BUTTON_SIZE + 2, this.height * this.TrackHeight / m_nContentHeight);			var nTrackHeight:Number = this.TrackHeight - m_spThumb.height - 1;			var nScrollAmount:Number = m_nScrollPos / this.OffscreenHeight;			var nYThumbPos:Number = nTrackHeight * nScrollAmount;			nYThumbPos = Math.max(nYThumbPos, 0);			nYThumbPos = Math.min(nYThumbPos, this.height - m_spThumb.height);			m_spThumb.y = BUTTON_SIZE + Math.round(nYThumbPos);			m_spThumbGrippers.NumVisibleGrippers = Math.floor(m_spThumb.height - 8 / 7);			m_spThumbGrippers.y = m_spThumb.y + (m_spThumb.height - m_spThumbGrippers.VisibleHeight) * 0.5;		}		private function get TrackHeight():Number		{			return this.height - BUTTON_SIZE * 2;		}		private function get OffscreenHeight():Number		{			return m_nContentHeight - this.height;		}		private function StartScrollTimer(strScrollDirection:String):void		{			m_strScrollDirection = strScrollDirection;			m_oScrollTimer.addEventListener(TimerEvent.TIMER, ScrollTimer_onTimer);			m_oScrollTimer.start();			stage.addEventListener(MouseEvent.MOUSE_UP, TimerStage_onMouseUp);			ScrollByLine(m_strScrollDirection);		}		private function ScrollByLine(strDirection:String):void		{			var nLine:int = (strDirection == UP) ? -1 : 1;			ScrollByLines(nLine);		}		private function UpdateThumbDrag():void		{			var nYPos:Number = this.mouseY - BUTTON_SIZE - m_nYDragOffset;			if (nYPos != m_nLastYPos)			{				m_nLastYPos = nYPos;				var nScrollAmount:Number = nYPos / (this.TrackHeight - m_spThumb.height);				nYPos = nScrollAmount * this.OffscreenHeight;				ScrollTo(nYPos);			}		}		private function Update():void		{			m_spUpButton.y = 0;			m_spDownButton.y = this.height - BUTTON_SIZE;			UpdateThumb();		}		private function DispatchScrollingEvent():void		{			if (m_nScrollPos != m_nLastScrollPos)			{				m_nLastScrollPos = m_nScrollPos;				dispatchEvent(new ScrollbarEvent(ScrollbarEvent.SCROLLING, m_nScrollPos));			}		}		private function onMouseWheel(evt:MouseEvent):void		{			if (this.stage != null)			{				ScrollByLines(-Math.round(evt.delta / 3));			}		}		private function UpButton_onMouseDown(evt:Event):void		{			evt.stopImmediatePropagation();			StartScrollTimer(UP);		}		private function DownButton_onMouseDown(evt:Event):void		{			evt.stopImmediatePropagation();			StartScrollTimer(DOWN);		}		private function ScrollTimer_onTimer(evt:Event):void		{			ScrollByLine(m_strScrollDirection);		}		private function TimerStage_onMouseUp(evt:Event):void		{			m_oScrollTimer.stop();			m_oScrollTimer.removeEventListener(TimerEvent.TIMER, ScrollTimer_onTimer);			stage.removeEventListener(MouseEvent.MOUSE_UP, TimerStage_onMouseUp);		}		private function onMouseDown(evt:Event):void		{			if (mouseY < m_spThumb.y || mouseY > m_spThumb.y + m_spThumb.height)			{				var nHeight:int = (mouseY < m_spThumb.y) ? -this.height : this.height;				ScrollTo(m_nScrollPos + nHeight);			}		}		private function Thumb_onMouseDown(evt:Event):void		{			evt.stopImmediatePropagation();			m_nYDragOffset = this.mouseY - m_spThumb.y;			stage.addEventListener(MouseEvent.MOUSE_MOVE, Stage_onMouseMove);			stage.addEventListener(MouseEvent.MOUSE_UP, Stage_onMouseUp);		}		private function Stage_onMouseMove(evt:Event):void		{			UpdateThumbDrag();		}		private function Stage_onMouseUp(evt:Event):void		{			stage.removeEventListener(MouseEvent.MOUSE_MOVE, Stage_onMouseMove);			stage.removeEventListener(MouseEvent.MOUSE_UP, Stage_onMouseUp);			UpdateThumbDrag();		}	}}